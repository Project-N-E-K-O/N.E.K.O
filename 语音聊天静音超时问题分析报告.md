# 语音聊天静音超时问题分析报告

## 📌 问题概述

**问题描述：** 语音聊天长时间未接入语音后自动重启，并在之后一直保持此状态。具体表现为语音聊天一段时间后提示"没有声音"，麦克风自动关闭，重新开启后立即又触发重置，导致无法正常对话。

**发现时间：** 2026-02-09

**影响版本：** 当前版本

**严重程度：** 🔴 高 - 影响用户正常使用语音聊天功能

---

## 🔍 根本原因分析

### Bug #1: 会话关闭后状态未完全重置

**问题位置：** `main_logic/omni_realtime_client.py:976-1012`

**问题代码：**
```python
async def close(self) -> None:
    """Close the WebSocket connection."""
    # 取消静默检测任务
    if self._silence_check_task:
        self._silence_check_task.cancel()
        try:
            await self._silence_check_task
        except asyncio.CancelledError:
            pass
        except Exception as e:
            logger.error(f"Error cancelling silence check task: {e}")
        finally:
            self._silence_check_task = None

    # ❌ 问题：没有重置这些状态变量！
    # self._silence_timeout_triggered 仍然为 True
    # self._last_speech_time 仍然保留旧时间戳
    # self._silence_reset_pending 可能为 True

    # 保存 debug 音频
    if self._audio_processor is not None:
        try:
            self._audio_processor.save_debug_audio()
        except Exception as e:
            logger.error(f"Error saving debug audio: {e}")

    # ❌ 问题：没有调用 self._audio_processor.reset()！

    if self.ws:
        try:
            await self.ws.close()
        except Exception as e:
            logger.error(f"Error closing websocket: {e}")
        finally:
            self.ws = None
            logger.info("WebSocket connection closed")
```

**问题说明：**
- `close()` 方法在关闭WebSocket连接时，没有重置关键的状态变量
- 导致下次连接时这些状态变量仍保留上次会话的值
- 特别是 `_silence_reset_pending` 标志可能导致下次会话立即触发缓存清空

---

### Bug #2: AudioProcessor 状态残留

**问题位置：** `utils/audio_processor.py:182-196`

**问题说明：**

`AudioProcessor` 类有公开的 `reset()` 方法（定义在第293-300行）可以重置状态：

```python
def reset(self) -> None:
    """
    Reset the processor state. Call this after each speech turn ends
    to prevent RNNoise state drift during silence/background noise.
    """
    self._reset_internal_state()
    self._last_speech_time = time.time()
    logger.info("🔄 AudioProcessor state reset (external call)")
```

但在 `OmniRealtimeClient.close()` 中从未调用此方法，导致：

| 状态变量 | 问题影响 |
|---------|---------|
| `_last_speech_time` | 保留上一次会话的时间戳，导致下次会话误判为长时间静音 |
| `_frame_buffer` | 可能还有残留音频数据 |
| `_last_speech_prob` | 保留旧的语音概率值 |
| `_agc_gain` | 保留旧的自动增益控制值 |
| `_denoiser` GRU状态 | RNNoise的循环神经网络状态未重置 |

---

## 🔄 问题复现流程

```
┌─────────────────────────────────────────────────────────────┐
│ 第一次会话：用户正常使用，然后触发超时                          │
└─────────────────────────────────────────────────────────────┘
1. 用户开始语音聊天
2. 长时间不说话（超过90秒）
3. OmniRealtimeClient._check_silence_timeout() 检测到超时
   └─ 设置 _silence_timeout_triggered = True
4. 调用 handle_silence_timeout()
   ├─ 清空音频缓存最后4秒
   ├─ 发送 "auto_close_mic" 消息到前端
   └─ 调用 end_session(by_server=True)
5. 调用 OmniRealtimeClient.close()
   ├─ 取消 _silence_check_task
   ├─ 调用 audio_processor.save_debug_audio()
   ├─ 关闭 WebSocket
   └─ ❌ 没有重置状态变量！
       ├─ _silence_reset_pending 可能为 True
       └─ AudioProcessor._last_speech_time 仍为旧值

┌─────────────────────────────────────────────────────────────┐
│ 第二次会话：问题开始出现                                       │
└─────────────────────────────────────────────────────────────┘
6. 用户再次点击开麦
7. 调用 OmniRealtimeClient.connect()
   ├─ ✅ _last_speech_time = time.time()  # OmniRealtimeClient自己的重置了
   ├─ ✅ _silence_timeout_triggered = False  # 重置为False
   └─ ✅ 启动新的 _silence_check_task
8. ❌ 但是：AudioProcessor 的 _last_speech_time 仍然是旧值！
9. 用户开始说话
10. AudioProcessor.process_chunk() 被调用
    ├─ current_time = time.time()
    ├─ 计算：current_time - _last_speech_time
    ├─ ❌ 结果：远大于4秒（因为_last_speech_time是上次会话的时间戳）
    ├─ 触发静音重置逻辑
    ├─ 调用 on_silence_reset() 回调
    └─ 标记 _silence_reset_pending = True
11. OmniRealtimeClient.stream_audio() 检测到 _silence_reset_pending
    ├─ 设置 _silence_reset_pending = False
    └─ 调用 clear_audio_buffer() 清空服务端缓存
12. ❌ 用户刚开始说话，音频缓存就被清空了！
13. 服务端没收到完整音频，可能无响应或响应异常
14. 如果用户继续不说话超过90秒，再次触发超时
15. ♻️ 循环重复步骤1-14...

┌─────────────────────────────────────────────────────────────┐
│ 结果：用户体验严重受损                                         │
└─────────────────────────────────────────────────────────────┘
- 每次重新开麦后立即触发缓存清空
- 用户说话内容被丢弃
- 无法正常对话
- 反复提示"没有声音"
```

---

## 🎯 涉及的关键机制

### 1. 90秒全局超时机制

**位置：** `omni_realtime_client.py:129-137, 210-246`

**配置：**
```python
# 只在 GLM 和 free API 时启用90秒静默超时，Qwen 和 Step 放行
self._enable_silence_timeout = self._api_type.lower() in ['glm', 'free']
self._silence_timeout_seconds = 90  # 90秒无语音输入则自动关闭
```

**检测逻辑：**
- 每10秒检查一次
- 当检测到用户开始说话时，重置 `_last_speech_time = time.time()`
- 超过90秒无语音则触发 `on_silence_timeout` 回调

---

### 2. 4秒RNNoise自动重置机制

**位置：** `audio_processor.py:88, 182-196`

**配置：**
```python
RESET_TIMEOUT_SECONDS = 4.0  # 4秒无语音后自动重置RNNoise状态
```

**重置逻辑：**
```python
# Check if we need to reset (after long silence or on request)
current_time = time.time()
silence_triggered = (current_time - self._last_speech_time > self.RESET_TIMEOUT_SECONDS)
if self._needs_reset or silence_triggered:
    if self._denoiser is not None:
        self._reset_internal_state()
        self._last_speech_time = current_time  # Prevent infinite reset loop
        logger.debug("🔄 RNNoise state auto-reset after silence")
        # 调用静音重置回调（仅在静音触发时，非手动请求时）
        if silence_triggered and self.on_silence_reset:
            try:
                self.on_silence_reset()
            except Exception as e:
                logger.error(f"❌ on_silence_reset callback error: {e}")
    self._needs_reset = False
```

**目的：**
- 防止RNNoise的GRU（门控循环单元）神经网络状态漂移
- 在长时间静音后清空内部缓存，提高下次语音识别质量

---

### 3. 静音重置回调链

**流程：**
```
AudioProcessor.process_chunk()
  └─ 检测到 4秒静音
      └─ 调用 on_silence_reset() 回调
          └─ (定义在 omni_realtime_client.py:248-250)
              └─ 设置 _silence_reset_pending = True
                  └─ OmniRealtimeClient.stream_audio() 检测到此标志
                      └─ 调用 clear_audio_buffer() 清空服务端缓存
```

**位置：**
- 回调注册：`omni_realtime_client.py:125-127`
- 回调实现：`omni_realtime_client.py:248-250`
- 检查和触发：`omni_realtime_client.py:532-536`

---

## 💡 解决方案

### 修复 #1：在 close() 中重置所有状态变量

**文件：** `main_logic/omni_realtime_client.py`

**位置：** 在第988行（`self._silence_check_task = None` 之后）添加

**修复代码：**
```python
# 重置静默超时相关状态
self._silence_timeout_triggered = False
self._last_speech_time = None
self._silence_reset_pending = False

# 重置音频处理器状态
if self._audio_processor is not None:
    self._audio_processor.reset()
```

**完整修复后的 close() 方法：**
```python
async def close(self) -> None:
    """Close the WebSocket connection."""
    # 取消静默检测任务
    if self._silence_check_task:
        self._silence_check_task.cancel()
        try:
            await self._silence_check_task
        except asyncio.CancelledError:
            pass
        except Exception as e:
            logger.error(f"Error cancelling silence check task: {e}")
        finally:
            self._silence_check_task = None

    # ✅ 重置静默超时相关状态
    self._silence_timeout_triggered = False
    self._last_speech_time = None
    self._silence_reset_pending = False

    # 保存 debug 音频
    if self._audio_processor is not None:
        try:
            self._audio_processor.save_debug_audio()
        except Exception as e:
            logger.error(f"Error saving debug audio: {e}")

    # ✅ 重置音频处理器状态
    if self._audio_processor is not None:
        self._audio_processor.reset()

    # Gemini uses different cleanup
    if self._is_gemini:
        await self._close_gemini()
        return

    if self.ws:
        try:
            # 尝试关闭websocket连接
            await self.ws.close()
        except Exception as e:
            logger.error(f"Error closing websocket: {e}")
        finally:
            self.ws = None  # 清空引用，防止后续误用
            logger.info("WebSocket connection closed")
    else:
        logger.warning("WebSocket connection is already closed or None")
```

---

### 修复 #2：在 connect() 开始时确保状态干净

**文件：** `main_logic/omni_realtime_client.py`

**位置：** 在第273行（`self.ws = await websockets.connect(...)` 之前）添加

**修复代码：**
```python
# 确保开始新连接时状态完全重置
self._silence_reset_pending = False
if self._audio_processor is not None:
    self._audio_processor.reset()
```

**完整修复后的 connect() 方法关键部分：**
```python
async def connect(self, instructions: str, native_audio=True) -> None:
    """Establish WebSocket connection with the Realtime API."""

    # Gemini uses google-genai SDK, not raw WebSocket
    if self._is_gemini:
        await self._connect_gemini(instructions, native_audio)
        return

    # ✅ 确保开始新连接时状态完全重置
    self._silence_reset_pending = False
    if self._audio_processor is not None:
        self._audio_processor.reset()

    # WebSocket-based APIs (GLM, Qwen, GPT, Step, Free)
    url = f"{self.base_url}?model={self.model}" if self.model != "free-model" else self.base_url
    headers = {
        "Authorization": f"Bearer {self.api_key}"
    }
    self.ws = await websockets.connect(url, additional_headers=headers)

    # 启动静默检测任务（只在启用时）
    self._last_speech_time = time.time()
    self._silence_timeout_triggered = False
    if self._silence_check_task:
        self._silence_check_task.cancel()
    # 只在启用静默超时时启动检测任务
    if self._enable_silence_timeout:
        self._silence_check_task = asyncio.create_task(self._check_silence_timeout())
    else:
        logger.info(f"静默超时检测已禁用（API类型: {self._api_type}），不会自动关闭会话")

    # ... 后续配置代码 ...
```

---

### 修复 #3：同样在 Gemini 的 close 中添加重置

**文件：** `main_logic/omni_realtime_client.py`

**位置：** 在 `_close_gemini()` 方法中，第1025行之前添加

**修复代码：**
```python
async def _close_gemini(self) -> None:
    """Close Gemini Live API session."""
    if self._gemini_context_manager:
        try:
            await self._gemini_context_manager.__aexit__(None, None, None)
        except Exception as e:
            logger.error(f"Error closing Gemini session: {e}")
        finally:
            self._gemini_session = None
            self._gemini_context_manager = None
            self.ws = None

            # ✅ 重置静默超时相关状态（与普通close()保持一致）
            self._silence_timeout_triggered = False
            self._last_speech_time = None
            self._silence_reset_pending = False

            # ✅ 重置音频处理器状态
            if self._audio_processor is not None:
                self._audio_processor.reset()

            logger.info("Gemini Live API session closed")
```

---

## 📊 影响范围分析

| API类型 | 是否受影响 | 严重程度 | 原因说明 |
|---------|----------|---------|---------|
| **GLM** | ✅ 是 | 🔴 高 | 启用了90秒超时，且是主要使用的API |
| **Free API** | ✅ 是 | 🔴 高 | 启用了90秒超时 |
| **Qwen** | ⚠️ 可能 | 🟡 中 | 未启用90秒超时，但AudioProcessor状态残留仍可能引发问题 |
| **Step** | ⚠️ 可能 | 🟡 中 | 未启用90秒超时，但AudioProcessor状态残留仍可能引发问题 |
| **Gemini** | ⚠️ 可能 | 🟡 中 | 使用不同的清理逻辑(`_close_gemini`)，但AudioProcessor状态残留仍可能引发问题 |

**受影响的用户场景：**
1. 用户在语音聊天时暂时离开（如接电话、处理其他事务）
2. 超过90秒后系统自动关闭麦克风
3. 用户回来后重新开启麦克风
4. 立即开始说话，但发现无法正常对话
5. 需要等待一段时间或多次重启才能恢复

---

## 🧪 验证方法

### 测试步骤：

1. **前置条件**
   - 使用 GLM 或 Free API
   - 确保语音输入设备正常工作

2. **复现问题（修复前）**
   ```
   a. 开始语音聊天
   b. 保持沉默超过90秒
   c. 观察到自动关闭麦克风提示
   d. 再次点击开麦
   e. 立即开始说话
   f. ❌ 观察到立即又提示"没有声音"或缓存被清空
   ```

3. **验证修复（修复后）**
   ```
   a. 开始语音聊天
   b. 保持沉默超过90秒
   c. 观察到自动关闭麦克风提示
   d. 再次点击开麦
   e. 立即开始说话
   f. ✅ 应该能正常对话，不会立即被清空缓存
   ```

4. **日志检查**
   - 修复前日志：
     ```
     🔄 RNNoise state auto-reset after silence
     （在刚开始说话时立即触发）
     ```
   - 修复后日志：
     ```
     🔄 AudioProcessor state reset (external call)
     （在close/connect时触发，而不是在说话时触发）
     ```

5. **边界测试**
   - 测试正常4秒静音重置是否仍正常工作
   - 测试多次开关麦克风是否稳定
   - 测试不同API类型的兼容性

---

## 📝 相关配置参数汇总

| 参数 | 文件位置 | 默认值 | 说明 |
|------|---------|--------|------|
| `_silence_timeout_seconds` | `omni_realtime_client.py:135` | 90秒 | 全局超时时间（只在GLM/Free API启用） |
| `RESET_TIMEOUT_SECONDS` | `audio_processor.py:88` | 4秒 | RNNoise自动重置超时 |
| `_silence_check_interval` | `omni_realtime_client.py:226` | 10秒 | 静音检查频率 |
| `speech_prob_threshold` | `audio_processor.py:268` | 0.2 | 语音概率阈值 |
| `SILENCE_DURATION_BYTES` | `core.py:413` | 120000字节 | 清空缓存大小（约4秒@16kHz） |

---

## 🔗 相关文件清单

### 核心文件

1. **`main_logic/omni_realtime_client.py`**
   - 行 129-137: 静音超时配置
   - 行 210-246: `_check_silence_timeout()` 方法
   - 行 248-250: `_on_silence_reset()` 回调
   - 行 260-395: `connect()` 方法
   - 行 532-536: 静音重置检查逻辑
   - 行 976-1012: `close()` 方法（需要修复）
   - 行 1014-1025: `_close_gemini()` 方法（需要修复）

2. **`utils/audio_processor.py`**
   - 行 88: `RESET_TIMEOUT_SECONDS` 配置
   - 行 182-196: 静音检测和重置逻辑
   - 行 280-291: `_reset_internal_state()` 方法
   - 行 293-300: `reset()` 方法

3. **`main_logic/core.py`**
   - 行 402-456: `handle_silence_timeout()` 方法
   - 行 1658-1737: `end_session()` 方法

### 前端文件

4. **`static/app.js`**
   - 行 877-886: `auto_close_mic` 消息处理
   - 行 2065-2106: `stopMicCapture()` 方法
   - 行 3600-3643: `stopRecording()` 方法

---

## ✅ 修复检查清单

- [ ] 修复 `OmniRealtimeClient.close()` 方法
  - [ ] 添加 `_silence_timeout_triggered = False`
  - [ ] 添加 `_last_speech_time = None`
  - [ ] 添加 `_silence_reset_pending = False`
  - [ ] 调用 `audio_processor.reset()`

- [ ] 修复 `OmniRealtimeClient.connect()` 方法
  - [ ] 在连接前添加 `_silence_reset_pending = False`
  - [ ] 在连接前调用 `audio_processor.reset()`

- [ ] 修复 `OmniRealtimeClient._close_gemini()` 方法
  - [ ] 添加与 `close()` 相同的状态重置逻辑

- [ ] 测试验证
  - [ ] GLM API 测试
  - [ ] Free API 测试
  - [ ] Qwen API 测试
  - [ ] Gemini API 测试
  - [ ] 多次开关麦克风稳定性测试

---

## 📚 参考资料

### 静音检测机制文档
- RNNoise：基于循环神经网络的实时降噪算法
- GRU（门控循环单元）：RNNoise使用的神经网络结构
- 状态漂移：长时间运行导致神经网络内部状态偏离正常范围

### 相关Issue
- 如果有GitHub Issue，在此处添加链接

---

## 📅 更新历史

| 日期 | 版本 | 说明 | 作者 |
|------|------|------|------|
| 2026-02-09 | 1.0 | 初始版本，完成问题分析 | Claude Code |

---

## 💬 备注

1. 此问题是一个典型的**状态管理不当**引起的Bug，在会话生命周期管理中需要确保所有状态在关闭和重新连接时都被正确重置。

2. AudioProcessor 的 `reset()` 方法已经存在并且实现完善，只是在调用链中被遗漏了，这是一个容易修复的问题。

3. 建议在未来的开发中：
   - 为关键的生命周期方法（如 `connect()`, `close()`）添加单元测试
   - 建立状态重置的检查清单
   - 考虑使用状态机模式管理复杂的会话状态

4. 此问题可能在代码库中存在较长时间，但只在特定使用场景下才会触发（需要触发90秒超时后再重新连接）。

---

**报告生成时间：** 2026-02-09
**分析工具：** Claude Code Explore Agent
**文档状态：** ✅ 已完成
