name: Build Desktop App (Cross-Platform)

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      version: { description: 'Release version', required: false, default: '' }
      electron_repo: { description: 'Frontend repo', required: false, default: 'Project-N-E-K-O/N.E.K.O.-PC' }
      electron_ref: { description: 'Frontend branch', required: false, default: 'main' }
      skip_signing: { description: 'Skip signing', required: false, default: 'true', type: choice, options: ['true', 'false'] }

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'

jobs:
  # ──────────────────────────────────────────────
  # Step 0: 计算版本号
  # ──────────────────────────────────────────────
  version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.calc.outputs.VERSION }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Calculate version
        id: calc
        run: |
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF#refs/tags/v}"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

  # ──────────────────────────────────────────────
  # Step 1: 构建 Python 后端 (Nuitka)
  # ──────────────────────────────────────────────
  build-python:
    needs: version
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            artifact_name: python-backend-win
            output_binary: projectneko_server.exe
          - os: macos-15
            python_arch: x64
            artifact_name: python-backend-mac-x64
            output_binary: projectneko_server
          - os: macos-latest
            artifact_name: python-backend-mac-arm64
            output_binary: projectneko_server
          - os: ubuntu-latest
            artifact_name: python-backend-linux
            output_binary: projectneko_server

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout backend repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          architecture: ${{ matrix.python_arch || '' }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4

      - name: Create venv and install dependencies
        shell: bash
        run: |
          uv venv .venv
          uv sync
          uv pip install --python .venv nuitka ordered-set zstandard
          
          # --- 核心：安装修正文件名后的自定义包 ---
          # 注意：包名 bilibili-api-pathchange 在文件名中必须写成 bilibili_api_pathchange
          WHL_FILE="bilibili_api_pathchange-0.1.0-py3-none-any.whl"
          
          if [ -f "$WHL_FILE" ]; then
            echo "检测到本地修改版 Wheel: $WHL_FILE"
            # 使用 --force-reinstall 确保覆盖原有依赖
            uv pip install --python .venv --force-reinstall "$WHL_FILE"
          else
            echo "错误：未在根目录找到 $WHL_FILE"
            ls -la
            exit 1
          fi

          # 验证导入逻辑（代码中依然使用 import bilibili_api）
          VENV_PY=$([[ "${{ matrix.os }}" == "windows-latest" ]] && echo ".venv/Scripts/python.exe" || echo ".venv/bin/python")
          $VENV_PY -c "import bilibili_api; print(f'验证成功: {bilibili_api.__file__}')" || exit 1

      - name: Generate config and prompts
        shell: bash
        run: |
          python -c "import json, os; configs={'config/characters.json':{'主人':{'档案名':'','性别':'','昵称':''},'猫娘':{},'当前猫娘':''},'config/core_config.json':{},'config/user_preferences.json':[]}; [ (os.makedirs(os.path.dirname(p), exist_ok=True), open(p,'w',encoding='utf-8').write(json.dumps(d, indent=2))) for p,d in configs.items() if not os.path.exists(p) ]"
          mkdir -p data/browser_use_prompts
          VENV_PY=$([[ -f ".venv/Scripts/python.exe" ]] && echo ".venv/Scripts/python.exe" || echo ".venv/bin/python")
          $VENV_PY -c "import shutil, browser_use.agent.system_prompts as sp; from pathlib import Path; [shutil.copy2(md, Path('data/browser_use_prompts')/md.name) for md in Path(sp.__file__).parent.glob('*.md')]" || echo "Skipping prompts copy"

      - name: Install System Deps (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y build-essential pkg-config portaudio19-dev patchelf ccache

      - name: Install Playwright
        shell: bash
        run: |
          VENV_PY=$([[ -f ".venv/Scripts/python.exe" ]] && echo ".venv/Scripts/python.exe" || echo ".venv/bin/python")
          PLAYWRIGHT_BROWSERS_PATH="$(pwd)/playwright_browsers" $VENV_PY -m playwright install chromium

      - name: Build with Nuitka (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          NUITKA_OPTS="--standalone --output-dir=dist --output-filename=projectneko_server --enable-plugin=dill-compat --assume-yes-for-downloads"
          NUITKA_OPTS="$NUITKA_OPTS --include-data-dir=config=config --include-data-dir=assets=assets --include-data-dir=templates=templates --include-data-dir=static=static"
          NUITKA_OPTS="$NUITKA_OPTS --include-data-dir=data/browser_use_prompts=data/browser_use_prompts"
          if [[ "$RUNNER_OS" != "macOS" ]]; then NUITKA_OPTS="$NUITKA_OPTS --include-data-dir=playwright_browsers=playwright_browsers"; fi
          
          # 包含所有必要的包和数据
          for pkg in uvicorn fastapi starlette jinja2 websockets langchain_community langchain_core langchain_openai main_server memory_server agent_server config brain main_logic main_routers memory utils steamworks browser_use browser_use_sdk playwright; do
            NUITKA_OPTS="$NUITKA_OPTS --include-package=$pkg"
          done
          NUITKA_OPTS="$NUITKA_OPTS --include-package-data=bilibili_api --include-package-data=browser_use --include-package-data=jinja2 --include-package-data=certifi"
          
          .venv/bin/python -m nuitka $NUITKA_OPTS launcher.py

      - name: Build with Nuitka (Windows)
        if: runner.os == 'Windows'
        shell: cmd
        run: |
          set NUITKA_OPTS=--standalone --output-dir="dist" --output-filename="projectneko_server.exe" --windows-icon-from-ico=assets/icon.ico --windows-console-mode=force --assume-yes-for-downloads --enable-plugin=dill-compat
          set NUITKA_OPTS=%NUITKA_OPTS% --include-data-dir=config=config --include-data-dir=assets=assets --include-data-dir=templates=templates --include-data-dir=static=static --include-data-dir=playwright_browsers=playwright_browsers --include-data-dir=data/browser_use_prompts=data/browser_use_prompts
          set NUITKA_OPTS=%NUITKA_OPTS% --include-package=uvicorn --include-package=fastapi --include-package=starlette --include-package=jinja2 --include-package=websockets --include-package=langchain_community --include-package=langchain_core --include-package=langchain_openai --include-package=main_server --include-package=memory_server --include-package=agent_server --include-package=config --include-package=brain --include-package=main_logic --include-package=main_routers --include-package=memory --include-package=utils --include-package=steamworks --include-package=browser_use --include-package=browser_use_sdk --include-package=playwright
          set NUITKA_OPTS=%NUITKA_OPTS% --include-package-data=bilibili_api --include-package-data=browser_use --include-package-data=playwright --include-package-data=jinja2 --include-package-data=certifi
          
          .venv\Scripts\python.exe -m nuitka %NUITKA_OPTS% launcher.py

      - name: Rename build output
        shell: bash
        run: |
          if [ -d "dist/launcher.dist" ]; then mv dist/launcher.dist dist/Xiao8; fi
          if [[ "$RUNNER_OS" == "macOS" && -d "playwright_browsers" ]]; then cp -R playwright_browsers dist/Xiao8/; fi

      - name: Upload Python backend artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: dist/Xiao8/

  # ──────────────────────────────────────────────
  # Step 2: 构建 Electron 桌面端
  # ──────────────────────────────────────────────
  build-electron:
    needs: [version, build-python]
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            platform: win
            python_artifact: python-backend-win
            electron_args: '--win'
            artifact_name: desktop-win-x64
          - os: macos-15
            platform: mac-x64
            python_artifact: python-backend-mac-x64
            electron_args: '--mac --x64'
            artifact_name: desktop-mac-x64
          - os: macos-latest
            platform: mac-arm64
            python_artifact: python-backend-mac-arm64
            electron_args: '--mac --arm64'
            artifact_name: desktop-mac-arm64
          - os: ubuntu-latest
            platform: linux
            python_artifact: python-backend-linux
            electron_args: '--linux'
            artifact_name: desktop-linux-x64

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout Electron frontend
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.inputs.electron_repo }}
          ref: ${{ github.event.inputs.electron_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          path: electron-app

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: electron-app/package-lock.json

      - name: Download Python backend
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.python_artifact }}
          path: electron-app/bin

      - name: Build Electron app
        working-directory: electron-app
        run: |
          npm ci
          # 针对 macOS 跳过签名
          if [[ "${{ matrix.os }}" == "macos"* ]]; then
            node -e "const p=JSON.parse(fs.readFileSync('package.json')); p.build.mac.identity=null; fs.writeFileSync('package.json', JSON.stringify(p,null,2))"
          fi
          npx electron-builder ${{ matrix.electron_args }} --publish never
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload desktop artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: electron-app/dist/

  # ──────────────────────────────────────────────
  # Step 3: 发布 Nightly 版本
  # ──────────────────────────────────────────────
  nightly:
    needs: [version, build-python, build-electron]
    runs-on: ubuntu-latest
    permissions: { contents: write }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with: { path: artifacts }
      - name: Organize release files
        run: |
          mkdir release
          find artifacts/desktop-* -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.deb" \) -exec cp {} release/ \;
      - name: Create nightly release
        env: { GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} }
        run: |
          gh release delete nightly --yes --cleanup-tag || true
          gh release create nightly release/* --title "Nightly Build $(date +%Y%m%d)" --prerelease --notes "Automatic build from ${{ needs.version.outputs.version }}"