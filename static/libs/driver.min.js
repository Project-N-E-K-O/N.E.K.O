/**
 * 简化版 Driver.js 实现
 * 用于 N.E.K.O 新手引导系统
 * 不依赖外部 CDN，完全本地实现
 */

(function(global) {
    'use strict';

    class Driver {
        constructor(options = {}) {
            this.options = {
                padding: options.padding || 8,
                allowClose: options.allowClose !== false,
                overlayClickNext: options.overlayClickNext || false,
                animate: options.animate !== false,
                className: options.className || 'driver-default',
                // i18n 按钮文本
                nextBtnText: options.nextBtnText || '下一步',
                prevBtnText: options.prevBtnText || '上一步',
                doneBtnText: options.doneBtnText || '完成',
                ...options
            };

            this.steps = [];
            this.currentStep = 0;
            this.isActive = false;
            this.overlay = null;
            this.popover = null;
            this.highlight = null;
            this.listeners = {};

            // 拖动状态
            this.isDragging = false;
            this.dragStartX = 0;
            this.dragStartY = 0;
            this.popoverStartX = 0;
            this.popoverStartY = 0;
            this.hasMoved = false;

            this.init();
        }

        init() {
            // 创建样式
            this.createStyles();
        }

        createStyles() {
            if (document.getElementById('driver-inline-styles')) return;

            const style = document.createElement('style');
            style.id = 'driver-inline-styles';
            style.textContent = `
                .driver-overlay {
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    right: 0 !important;
                    bottom: 0 !important;
                    background: rgba(0, 0, 0, 0.15) !important;
                    z-index: 99998 !important;
                }
                .driver-highlight {
                    position: fixed !important;
                    border: 3px solid #44b7fe !important;
                    border-radius: 8px !important;
                    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.15), 0 0 30px rgba(68, 183, 254, 0.8), inset 0 0 30px rgba(255, 255, 255, 0.15) !important;
                    z-index: 99999 !important;
                    pointer-events: none !important;
                    background: rgba(255, 255, 255, 0.05) !important;
                }
                .driver-popover {
                    position: fixed !important;
                    background: rgba(30, 30, 40, 0.95) !important;
                    border: 1px solid rgba(68, 183, 254, 0.3) !important;
                    border-radius: 12px !important;
                    padding: 20px !important;
                    max-width: 380px !important;
                    z-index: 100000 !important;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4) !important;
                    backdrop-filter: blur(10px) !important;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
                }
                .driver-popover-title {
                    color: #44b7fe !important;
                    font-size: 16px !important;
                    font-weight: 600 !important;
                    margin-bottom: 12px !important;
                    letter-spacing: 0.5px !important;
                    cursor: move !important;
                    user-select: none !important;
                }
                .driver-popover-description {
                    color: rgba(255, 255, 255, 0.85) !important;
                    font-size: 14px !important;
                    line-height: 1.6 !important;
                    margin-bottom: 16px !important;
                }
                .driver-popover-footer {
                    display: flex !important;
                    gap: 10px !important;
                    justify-content: flex-end !important;
                    margin-top: 16px !important;
                }
                .driver-popover-footer button {
                    padding: 8px 16px !important;
                    border-radius: 6px !important;
                    font-size: 13px !important;
                    font-weight: 500 !important;
                    cursor: pointer !important;
                    border: none !important;
                    outline: none !important;
                    transition: all 0.2s ease !important;
                    pointer-events: auto !important;
                    z-index: 100001 !important;
                }
                .driver-popover-footer button:first-child {
                    background: rgba(68, 183, 254, 0.15) !important;
                    color: #44b7fe !important;
                    border: 1px solid rgba(68, 183, 254, 0.3) !important;
                }
                .driver-popover-footer button:first-child:hover {
                    background: rgba(68, 183, 254, 0.25) !important;
                    border-color: rgba(68, 183, 254, 0.5) !important;
                }
                .driver-popover-footer button:last-child {
                    background: linear-gradient(135deg, #44b7fe 0%, #40C5F1 100%) !important;
                    color: #fff !important;
                }
                .driver-popover-footer button:last-child:hover {
                    background: linear-gradient(135deg, #3aa8f0 0%, #38b8e3 100%) !important;
                    box-shadow: 0 4px 12px rgba(68, 183, 254, 0.4) !important;
                }
            `;
            document.head.appendChild(style);
        }

        setSteps(steps) {
            this.steps = steps;
        }

        start() {
            if (this.steps.length === 0) {
                console.warn('[Driver] No steps defined');
                return;
            }

            this.isActive = true;
            this.currentStep = 0;
            this.showStep(0);
        }

        showStep(index) {
            if (index < 0 || index >= this.steps.length) {
                this.destroy();
                return;
            }

            this.currentStep = index;
            const step = this.steps[index];

            // 移除旧的高亮和弹窗
            this.removeHighlight();
            this.removePopover();

            // 获取目标元素
            const element = document.querySelector(step.element);
            if (!element) {
                console.warn(`[Driver] Element not found, skipping: ${step.element}`);
                // 自动跳到下一步
                this.showStep(index + 1);
                return;
            }

            // 先滚动到元素，然后创建高亮和弹窗
            this.scrollToElementAndHighlight(element, step.popover, index);
        }

        // 滚动到元素并创建高亮框
        scrollToElementAndHighlight(element, popover, stepIndex) {
            // 检查元素是否在视口内
            const rect = element.getBoundingClientRect();
            const isInViewport = (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );

            if (isInViewport) {
                // 元素已在视口内，直接创建高亮
                console.log('[Driver] 元素已在视口内');
                this.createHighlight(element);
                this.createPopover(element, popover, stepIndex);
                this.emit('next');
            } else {
                // 元素不在视口内，需要滚动
                console.log('[Driver] 元素不在视口内，正在滚动...');

                // 使用 scrollIntoView 滚动到元素
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // 监听滚动停止来创建高亮框
                let scrollTimer = null;
                let created = false;

                const createAfterScroll = () => {
                    if (created) return;
                    created = true;
                    window.removeEventListener('scroll', onScroll);
                    console.log('[Driver] 滚动完成，创建高亮框');
                    this.createHighlight(element);
                    this.createPopover(element, popover, stepIndex);
                    this.emit('next');
                };

                const onScroll = () => {
                    if (scrollTimer) clearTimeout(scrollTimer);
                    scrollTimer = setTimeout(createAfterScroll, 150);
                };

                window.addEventListener('scroll', onScroll, { passive: true });

                // 保底：最多等 1200ms
                setTimeout(() => {
                    window.removeEventListener('scroll', onScroll);
                    createAfterScroll();
                }, 1200);
            }
        }

        createHighlight(element) {
            const rect = element.getBoundingClientRect();
            const padding = this.options.padding;

            // 创建遮罩层
            this.overlay = document.createElement('div');
            this.overlay.className = 'driver-overlay';
            document.body.appendChild(this.overlay);

            // 创建高亮框
            this.highlight = document.createElement('div');
            this.highlight.className = 'driver-highlight';
            this.highlight.style.top = (rect.top - padding) + 'px';
            this.highlight.style.left = (rect.left - padding) + 'px';
            this.highlight.style.width = (rect.width + padding * 2) + 'px';
            this.highlight.style.height = (rect.height + padding * 2) + 'px';
            document.body.appendChild(this.highlight);

            console.log('[Driver] Highlight created at:', {
                top: rect.top - padding,
                left: rect.left - padding,
                width: rect.width + padding * 2,
                height: rect.height + padding * 2
            });
        }

        createPopover(element, content, stepIndex) {
            this.popover = document.createElement('div');
            this.popover.className = 'driver-popover';

            let html = '';
            if (content.title) {
                html += `<div class="driver-popover-title">${content.title}</div>`;
            }
            if (content.description) {
                html += `<div class="driver-popover-description">${content.description}</div>`;
            }

            html += '<div class="driver-popover-footer">';
            if (stepIndex > 0) {
                html += `<button class="driver-prev">${this.options.prevBtnText}</button>`;
            }
            if (stepIndex < this.steps.length - 1) {
                html += `<button class="driver-next">${this.options.nextBtnText}</button>`;
            } else {
                html += `<button class="driver-finish">${this.options.doneBtnText}</button>`;
            }
            html += '</div>';

            this.popover.innerHTML = html;
            document.body.appendChild(this.popover);

            console.log('[Driver] Popover created');

            // 绑定拖动事件到标题栏
            const titleElement = this.popover.querySelector('.driver-popover-title');
            if (titleElement) {
                this.bindDragEvents(titleElement, this.popover);
            }

            // 绑定按钮事件
            const prevBtn = this.popover.querySelector('.driver-prev');
            const nextBtn = this.popover.querySelector('.driver-next');
            const finishBtn = this.popover.querySelector('.driver-finish');

            if (prevBtn) {
                prevBtn.addEventListener('click', () => this.showStep(stepIndex - 1));
            }
            if (nextBtn) {
                nextBtn.addEventListener('click', () => this.showStep(stepIndex + 1));
            }
            if (finishBtn) {
                finishBtn.addEventListener('click', () => this.destroy());
            }

            // 定位弹窗（传入元素信息以便智能定位）
            setTimeout(() => this.positionPopover(element), 0);
        }

        positionPopover(element) {
            if (!this.popover) return;

            const popoverWidth = 380;
            const popoverHeight = this.popover.offsetHeight;
            const margin = 20;

            // 如果有元素，尝试定位到元素旁边
            if (element) {
                const rect = element.getBoundingClientRect();

                // 尝试定位到右侧
                let left = rect.right + margin;
                let top = rect.top;

                // 如果右侧空间不够，尝试左侧
                if (left + popoverWidth + margin > window.innerWidth) {
                    left = rect.left - popoverWidth - margin;
                }

                // 如果左侧也不够，居中显示
                if (left < margin) {
                    left = (window.innerWidth - popoverWidth) / 2;
                    top = (window.innerHeight - popoverHeight) / 2;
                } else {
                    // 确保垂直方向不超出视口
                    if (top + popoverHeight > window.innerHeight - margin) {
                        top = window.innerHeight - popoverHeight - margin;
                    }
                    if (top < margin) {
                        top = margin;
                    }
                }

                this.popover.style.top = top + 'px';
                this.popover.style.left = left + 'px';
            } else {
                // 没有元素，居中显示
                let top = (window.innerHeight - popoverHeight) / 2;
                let left = (window.innerWidth - popoverWidth) / 2;

                // 确保不超出视口
                if (top < margin) top = margin;
                if (left < margin) left = margin;
                if (top + popoverHeight > window.innerHeight - margin) {
                    top = window.innerHeight - popoverHeight - margin;
                }

                this.popover.style.top = top + 'px';
                this.popover.style.left = left + 'px';
            }

            console.log('[Driver] Popover positioned');
        }

        removeHighlight() {
            if (this.overlay) {
                this.overlay.remove();
                this.overlay = null;
            }
            if (this.highlight) {
                this.highlight.remove();
                this.highlight = null;
            }
        }

        removePopover() {
            if (this.popover) {
                this.popover.remove();
                this.popover = null;
            }
        }

        destroy() {
            console.log('[Driver] Destroying driver');
            this.removeHighlight();
            this.removePopover();
            this.isActive = false;
            this.emit('destroy');
        }

        /**
         * 刷新高亮框位置
         * 当页面滚动后调用此方法来更新高亮框的位置
         */
        refresh() {
            if (!this.isActive || this.currentStep >= this.steps.length) {
                return;
            }

            const step = this.steps[this.currentStep];
            const element = document.querySelector(step.element);

            if (!element) {
                console.warn('[Driver] refresh: Element not found:', step.element);
                return;
            }

            // 重新计算元素位置
            const rect = element.getBoundingClientRect();
            const padding = this.options.padding;

            // 更新高亮框位置
            if (this.highlight) {
                this.highlight.style.top = (rect.top - padding) + 'px';
                this.highlight.style.left = (rect.left - padding) + 'px';
                this.highlight.style.width = (rect.width + padding * 2) + 'px';
                this.highlight.style.height = (rect.height + padding * 2) + 'px';

                console.log('[Driver] Highlight refreshed at:', {
                    top: rect.top - padding,
                    left: rect.left - padding,
                    width: rect.width + padding * 2,
                    height: rect.height + padding * 2
                });
            }

            // 更新弹窗位置
            if (this.popover) {
                this.positionPopover(element);
            }
        }

        on(event, callback) {
            if (!this.listeners[event]) {
                this.listeners[event] = [];
            }
            this.listeners[event].push(callback);
        }

        emit(event) {
            if (this.listeners[event]) {
                this.listeners[event].forEach(callback => callback());
            }
        }

        // 绑定拖动事件
        bindDragEvents(dragHandle, popover) {
            const handleDragStart = (e) => {
                // 防止在按钮上触发拖动
                if (e.target.tagName === 'BUTTON') {
                    return;
                }

                this.isDragging = true;
                this.hasMoved = false;
                popover.classList.add('dragging');

                // 获取初始坐标（支持鼠标和触摸）
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                this.dragStartX = clientX;
                this.dragStartY = clientY;

                // 获取 popover 当前位置
                const rect = popover.getBoundingClientRect();
                this.popoverStartX = rect.left;
                this.popoverStartY = rect.top;

                e.preventDefault();
            };

            const handleDragMove = (e) => {
                if (!this.isDragging) return;

                // 获取当前坐标（支持鼠标和触摸）
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - this.dragStartX;
                const deltaY = clientY - this.dragStartY;

                // 只有移动超过 5px 才认为是拖动
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    this.hasMoved = true;
                }

                if (!this.hasMoved) return;

                // 计算新位置
                let newLeft = this.popoverStartX + deltaX;
                let newTop = this.popoverStartY + deltaY;

                // 边界检测
                const popoverRect = popover.getBoundingClientRect();
                const margin = 20;

                newLeft = Math.max(margin, Math.min(window.innerWidth - popoverRect.width - margin, newLeft));
                newTop = Math.max(margin, Math.min(window.innerHeight - popoverRect.height - margin, newTop));

                // 更新位置
                popover.style.left = newLeft + 'px';
                popover.style.top = newTop + 'px';

                e.preventDefault();
            };

            const handleDragEnd = (e) => {
                if (!this.isDragging) return;

                this.isDragging = false;
                popover.classList.remove('dragging');

                e.preventDefault();
            };

            // 绑定鼠标事件
            dragHandle.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            // 绑定触摸事件（移动设备）
            dragHandle.addEventListener('touchstart', handleDragStart, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd, { passive: false });

            // 保存事件处理器引用，以便后续清理
            if (!this.dragHandlers) {
                this.dragHandlers = [];
            }
            this.dragHandlers.push({
                handleDragMove,
                handleDragEnd
            });
        }
    }

    // 暴露到全局
    global.driver = Driver;
    global.Driver = Driver;

    console.log('[Driver] Driver.js loaded successfully');

})(window);
